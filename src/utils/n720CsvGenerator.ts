/**
 * N720 CSV Generator
 *
 * Generates CSV content for N720 gateway edge configuration.
 * The CSV is used to configure data acquisition (Modbus devices and registers).
 */

import { getMeterConfig, getN720DataTypeCode, type MeterType } from '../config/meterConfigs';

export interface N720MeterConfig {
  name: string;           // Meter name (used as device name)
  slaveAddress: number;   // Modbus slave address (used in SC line for actual Modbus communication)
  meterType: MeterType;   // Type of meter (EM4371, XMC34F, etc.)
  meterIndex: number;     // 1-based index used for data point suffix (e.g., v_l1_1 for first meter)
  port?: string;          // Serial port (default: Uart1)
  protocol?: number;      // 1 = Modbus RTU, 3 = Modbus TCP (default: 1)
  pollingInterval?: number; // Polling interval in ms (default: 100)
}

/**
 * Extract all existing entries from CSV content
 * This preserves ALL SC and C lines from the existing configuration,
 * which is important to keep system variables (mac, ip, time, etc.) working.
 *
 * @param existingCsv - The existing CSV content
 * @param excludeDeviceNames - Optional list of device names to exclude (e.g., meters we're replacing)
 */
export function extractExistingEntries(existingCsv: string, excludeDeviceNames: string[] = []): {
  scLines: string[];
  stateLines: string[];
  dataLines: string[];
} {
  const scLines: string[] = [];
  const stateLines: string[] = [];
  const dataLines: string[] = [];

  if (!existingCsv) {
    return { scLines, stateLines, dataLines };
  }

  const lines = existingCsv.split(/\r?\n/).filter(line => line.trim());

  // Normalize exclude list for comparison
  const excludeSet = new Set(excludeDeviceNames.map(n => n.toLowerCase()));

  for (const line of lines) {
    // Skip header line
    if (line.startsWith('V,')) {
      continue;
    }

    // Parse device name from the line (second field)
    const parts = line.split(',');
    const deviceName = parts[1] || '';
    const deviceNameLower = deviceName.toLowerCase();

    // Skip if this device is in the exclude list
    if (excludeSet.has(deviceNameLower)) {
      continue;
    }

    // IMPORTANT: DO NOT skip System_Slave entries!
    // The System_Slave SC line must be preserved from the existing CSV
    // otherwise sys_mac, sys_sn, sys_ver, etc. will be reset to 0 after restart.
    // The firmware needs this entry to properly populate system variables.

    // Categorize the line
    if (line.startsWith('SC,')) {
      scLines.push(line);
    } else if (line.startsWith('C,')) {
      // Check if it's a state line (has "_state" in the point name or "State" in register field)
      const pointName = parts[2] || '';
      const registerField = parts[12] || '';
      if (pointName.endsWith('_state') || registerField === 'State') {
        stateLines.push(line);
      } else {
        dataLines.push(line);
      }
    }
  }

  return { scLines, stateLines, dataLines };
}

/**
 * Generate complete N720 edge CSV content for one or more meters
 *
 * The N720 CSV format requires a specific ordering:
 * 1. Header line (V,V1.0,N7X0,;)
 * 2. ALL SC lines (slave configurations) first - including existing entries
 * 3. ALL state point C lines
 * 4. ALL data point C lines
 *
 * This ordering is critical - mixing SC and C lines per meter causes errors.
 *
 * @param meters - Array of meter configurations to add
 * @param existingCsv - Optional existing CSV to preserve entries from (e.g., system variables)
 */
export function generateN720EdgeCsv(meters: N720MeterConfig[], existingCsv?: string): string {
  const lines: string[] = [];
  const scLines: string[] = [];
  const stateLines: string[] = [];
  const dataLines: string[] = [];

  // Header line (required)
  lines.push('V,V1.0,N7X0,;');

  // Note: System_Slave is auto-generated by firmware when "Save Current + Restart" is clicked
  // We don't need to include it in the CSV - the gateway adds it automatically

  // Get sanitized names of meters we're adding (to exclude from existing entries)
  const newMeterNames = meters.map(m => {
    const sanitized = m.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
    return sanitized.substring(0, 14);
  });

  // Preserve existing entries from CSV, excluding meters we're replacing
  if (existingCsv) {
    const existingEntries = extractExistingEntries(existingCsv, newMeterNames);
    scLines.push(...existingEntries.scLines);
    stateLines.push(...existingEntries.stateLines);
    dataLines.push(...existingEntries.dataLines);
    console.log(`Preserved ${existingEntries.scLines.length} SC lines, ${existingEntries.stateLines.length} state lines, ${existingEntries.dataLines.length} data lines from existing config`);
  }

  // Generate lines for each new meter, separating by type
  // IMPORTANT: Each meter must have a unique meterIndex for data point naming
  for (let meterArrayIndex = 0; meterArrayIndex < meters.length; meterArrayIndex++) {
    const meter = meters[meterArrayIndex];
    const {
      name: rawName,
      slaveAddress,
      meterType,
      port = 'Uart1',
      protocol = 1,
      pollingInterval = 100,
    } = meter;

    // Use the meter's meterIndex if provided, otherwise calculate from array position (1-based)
    // This ensures each meter gets a unique index even if meterIndex wasn't explicitly set
    const meterIndex = meter.meterIndex ?? (meterArrayIndex + 1);

    console.log(`CSV Gen: Processing meter ${meterArrayIndex}: name="${rawName}", meterIndex=${meterIndex}, meterType="${meterType}"`);

    if (meterIndex === undefined || meterIndex === null) {
      console.error(`CSV Gen ERROR: meterIndex is undefined for meter "${rawName}"`);
    }

    // Sanitize meter name
    const sanitized = rawName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
    const name = sanitized.substring(0, 14);

    const meterConfig = getMeterConfig('N720', meterType);
    if (!meterConfig) {
      console.error(`Meter type ${meterType} not supported on N720`);
      continue;
    }

    // SC line - slaveAddress is the actual Modbus slave address for communication
    scLines.push(`SC,${name},,${protocol},${slaveAddress},${pollingInterval},0,0,,${port},;`);

    // State point line
    stateLines.push(`C,${name},${name}_state,,18,0,0,0,0,0,0,,State,0,0,0,0,0,0,,;`);

    // Data point lines - use meterIndex for suffix (1-based: first meter = _1)
    // Format: C,XMC34F1,v_l1_1,,6,0,0,0,0,0,0,,404097,0,0,1,100,0,2,,;
    // Key fields: dataType at pos 4, floatDecimals at pos 5, pollingFlag at pos 15, decimals at pos 18
    for (const dataPoint of meterConfig.dataPoints) {
      const pointName = `${dataPoint.name}_${meterIndex}`;
      const dataTypeCode = getN720DataTypeCode(dataPoint.dataType);
      const registerAddress = dataPoint.registerAddress;
      const pollingFlag = 1; // Template uses 1
      const timeout = dataPoint.responseTimeout;
      const decimals = dataPoint.decimals ?? 2; // Use config decimals or default to 2
      const floatDecimals = dataPoint.floatDecimals ?? 0; // Use config floatDecimals or default to 0

      console.log(`CSV Gen: ${pointName} - decimals=${decimals}, floatDecimals=${floatDecimals}, from config: ${JSON.stringify({d: dataPoint.decimals, fd: dataPoint.floatDecimals})}`);

      // Format: C,{slave},{point},,{dataType},{floatDec},0,0,0,0,0,,{register},0,0,{poll},{timeout},0,{decimals},,;
      // - floatDecimals at position 5 (for float32 types, typically 2)
      // - decimals at position 18 (from config, default 2)
      // - NO apostrophe after register
      dataLines.push(
        `C,${name},${pointName},,${dataTypeCode},${floatDecimals},0,0,0,0,0,,${registerAddress},0,0,${pollingFlag},${timeout},0,${decimals},,;`
      );
    }
  }

  // Combine in correct order: SC lines, then state lines, then data lines
  lines.push(...scLines);
  lines.push(...stateLines);
  lines.push(...dataLines);

  console.log(`CSV Gen Summary: ${scLines.length} SC lines, ${stateLines.length} state lines, ${dataLines.length} data lines`);
  console.log(`CSV Gen: SC lines (meter names):`, scLines.map(l => l.split(',')[1]));
  // Log a sample of data lines to verify meterIndex
  if (dataLines.length > 0) {
    console.log(`CSV Gen: Sample data point names:`, dataLines.slice(0, 5).map(l => l.split(',')[2]));
  }

  // N720 gateway requires CRLF line endings (Windows-style)
  // IMPORTANT: Must end with trailing CRLF (verified from HAR capture)
  return lines.join('\r\n') + '\r\n';
}

/**
 * Generate CSV for a single meter (convenience function)
 */
export function generateSingleMeterCsv(
  name: string,
  slaveAddress: number,
  meterType: MeterType,
  meterIndex: number = 0,
  port: string = 'Uart1'
): string {
  return generateN720EdgeCsv([{
    name,
    slaveAddress,
    meterType,
    meterIndex,
    port,
  }]);
}

/**
 * Get supported meter types for N720
 */
export function getN720SupportedMeterTypes(): MeterType[] {
  return ['XMC34F', 'EM4371', 'Sfere720', 'EnergyNG9', 'TAC4300'];
}

/**
 * Parsed meter info from CSV
 */
export interface ParsedN720Meter {
  name: string;
  slaveAddress: number;
  protocol: number;
  port: string;
  pollingInterval: number;
  dataPointCount: number;
}

/**
 * Parse existing N720 CSV content to extract meter information
 * Returns the list of meters found in the CSV
 */
export function parseN720EdgeCsv(csvContent: string): ParsedN720Meter[] {
  const meters: ParsedN720Meter[] = [];
  const lines = csvContent.split('\n').filter(line => line.trim());

  for (const line of lines) {
    // Parse SC lines (Slave Configuration)
    // Format: SC,{SlaveName},,{Protocol},{SlaveAddr},{PollingInterval},0,0,,{Port},;
    // Note: Position 3 is protocol, Position 4 is slave address (based on working CSV analysis)
    if (line.startsWith('SC,')) {
      const parts = line.split(',');
      if (parts.length >= 10) {
        const name = parts[1];
        const protocol = parseInt(parts[3], 10) || 1;
        const slaveAddress = parseInt(parts[4], 10) || 1;
        const pollingInterval = parseInt(parts[5], 10) || 100;
        const port = parts[9] || 'Uart1';

        meters.push({
          name,
          slaveAddress,
          protocol,
          port,
          pollingInterval,
          dataPointCount: 0, // Will be counted from C lines
        });
      }
    }
    // Count C lines for data points
    else if (line.startsWith('C,')) {
      const parts = line.split(',');
      if (parts.length >= 2) {
        const meterName = parts[1];
        const meter = meters.find(m => m.name === meterName);
        if (meter) {
          meter.dataPointCount++;
        }
      }
    }
  }

  return meters;
}

/**
 * Append a new meter to existing CSV content
 * This preserves all existing meters and adds the new one
 *
 * Note: This regenerates the entire CSV to ensure proper ordering
 * (SC lines first, then state lines, then data lines)
 */
export function appendMeterToCsv(
  existingCsv: string,
  newMeter: N720MeterConfig
): string {
  // If existing CSV is empty or invalid, create new CSV with just the new meter
  if (!existingCsv.trim() || !existingCsv.includes('V,V1.0,N7X0')) {
    return generateN720EdgeCsv([newMeter]);
  }

  // Check if meter with same name already exists
  const existingMeters = parseN720EdgeCsv(existingCsv);
  if (existingMeters.some(m => m.name === newMeter.name)) {
    console.warn(`Meter with name "${newMeter.name}" already exists. Adding with suffix.`);
    newMeter.name = `${newMeter.name}_${existingMeters.length}`;
  }

  // Regenerate the entire CSV with proper ordering
  // We need to convert parsed meters back to N720MeterConfig format
  // For now, just generate the new meter CSV (proper solution would track meter configs)
  // This is a simplified approach - in practice the full meter list should be regenerated
  console.warn('appendMeterToCsv: For best results, regenerate entire CSV with generateN720EdgeCsv');
  return generateN720EdgeCsv([newMeter]);
}

/**
 * Find the next available meter index from existing CSV
 */
export function getNextMeterIndex(csvContent: string): number {
  const meters = parseN720EdgeCsv(csvContent);
  return meters.length;
}

/**
 * Generate N720 report template for a meter
 * This creates the JSON template structure used in the report group
 * Format: { "MeterName": [{ "ts": "sys_timestamp_ms", "values": { "field": "field_meterIndex", ... }}] }
 *
 * Note: The field suffix uses the 0-based meter index, NOT the Modbus slave address.
 * This must match the CSV data point naming (e.g., v_l1_0 for first meter, v_l1_1 for second)
 */
export function generateN720ReportTemplate(
  meterName: string,
  meterType: MeterType,
  meterIndex: number
): Record<string, unknown> {
  const meterConfig = getMeterConfig('N720', meterType);
  if (!meterConfig) {
    console.error(`Meter type ${meterType} not supported on N720`);
    return {};
  }

  // Build the values object mapping field names to meter index suffixed variable names
  // This matches the CSV format where data points use 0-based index (e.g., v_l1_0 for first meter)
  const values: Record<string, string> = {};
  for (const field of meterConfig.reportingFields) {
    values[field] = `${field}_${meterIndex}`;
  }

  // N720 ThingsBoard format with timestamp
  return {
    [meterName]: [{
      ts: 'sys_timestamp_ms',
      values,
    }],
  };
}

/**
 * Merge multiple report templates into one
 * Used when adding a new meter to preserve existing report template
 */
export function mergeN720ReportTemplates(
  existingTemplate: Record<string, unknown>,
  newTemplate: Record<string, unknown>
): Record<string, unknown> {
  return {
    ...existingTemplate,
    ...newTemplate,
  };
}

/**
 * Generate the edge_report JSON configuration for N720
 * This is the full configuration that needs to be uploaded to /upload/nv1 and /upload/nv2
 *
 * The format follows the N720 import/export JSON structure with tmpl_cont
 *
 * @param meters - Array of meter configurations
 * @param reportTopic - MQTT topic for reporting (without leading slash)
 * @param reportingInterval - Reporting period in seconds
 * @returns JSON string of the edge_report configuration
 */
export interface N720ReportGroupConfig {
  name: string;
  topic: string;
  period: number;
  template: Record<string, unknown>;
}

/**
 * Generate the tmpl_cont object for a meter
 * This creates the template content structure used in the report group
 * Format: { "MeterName": { "field": "field_meterIndex", ... }, "time": "sys_local_time" }
 *
 * Note: The field suffix uses the 0-based meter index, NOT the Modbus slave address.
 * This must match the CSV data point naming (e.g., v_l1_0 for first meter)
 */
function generateN720TmplCont(
  meterName: string,
  meterType: MeterType,
  meterIndex: number
): Record<string, unknown> {
  const meterConfig = getMeterConfig('N720', meterType);
  if (!meterConfig) {
    console.error(`Meter type ${meterType} not supported on N720`);
    return { time: 'sys_local_time' };
  }

  // Build the values object mapping field names to meter index suffixed variable names
  // This matches the CSV format where data points use 0-based index (e.g., v_l1_0 for first meter)
  const meterValues: Record<string, string> = {};
  for (const field of meterConfig.reportingFields) {
    meterValues[field] = `${field}_${meterIndex}`;
  }

  // Return the tmpl_cont structure
  return {
    [meterName]: meterValues,
    time: 'sys_local_time',
  };
}

export function generateN720EdgeReportConfig(
  meters: Array<{
    name: string;
    slaveAddress: number;
    meterType: MeterType;
  }>,
  reportTopic: string,
  reportingInterval: number = 60
): string {
  interface N720ReportGroup {
    name: string;
    link: string;
    topic: string;
    qos: number;
    retention: number;
    cond: {
      period: number;
      timed: {
        type: number;
        hh: number;
        mm: number;
      };
    };
    data_report_type: number;
    change_report_type: number;
    err_enable: number;
    err_info: string;
    tmpl_file: string;
    fkey_md5: string;
    ucld_node: string[];
    tmpl_cont: Record<string, unknown>;
  }

  const groups: N720ReportGroup[] = [];

  // Generate a report group for each meter
  for (let i = 0; i < meters.length; i++) {
    const meter = meters[i];
    // For report group name: sanitize and truncate (gateway requires 1-20 bytes, a-z/A-Z/0-9/_)
    const sanitizedForGateway = meter.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
    // Limit to 13 chars to allow for "_report" suffix (7 chars) = 20 total
    const truncatedName = sanitizedForGateway.substring(0, 13);
    // Use 0-based meter index for the data point suffix (matches native UI CSV naming convention)
    // Template content uses original meter name with spaces (MQTT payload, no restrictions)
    const tmplCont = generateN720TmplCont(meter.name, meter.meterType, i);

    // Clean topic (ensure no leading slash for this format)
    const cleanTopic = reportTopic.startsWith('/') ? reportTopic.substring(1) : reportTopic;

    groups.push({
      name: `${truncatedName}_report`,   // Group name: <MeterName>_report (max 20 chars)
      link: 'MQTT1',                      // Use MQTT1 channel
      topic: cleanTopic,                  // MQTT topic
      qos: 1,                             // QoS 1 (at-least-once)
      retention: 0,                       // No message retention
      cond: {
        period: reportingInterval,        // Reporting period in seconds
        timed: {
          type: 0,                        // Disabled
          hh: 0,
          mm: 0,
        },
      },
      data_report_type: 0,                // Primary type
      change_report_type: 0,              // No change reporting
      err_enable: 0,                      // Error reporting disabled
      err_info: 'error',                  // Error message placeholder
      tmpl_file: '',                      // No external template file
      fkey_md5: '00000000000000000000000000000000',  // Empty MD5
      ucld_node: [],                      // No cloud nodes
      tmpl_cont: tmplCont,                // Template content
    });
  }

  // The edge_report format expected by N720
  const edgeReport = {
    group: groups,
  };

  // Return as JSON string (the upload endpoint expects the raw JSON content)
  return JSON.stringify(edgeReport);
}

/**
 * Generate the link configuration for N720
 * This maps serial ports (Uart1, Uart2) to the edge computing function
 * The link config is critical - without it, the gateway returns "slave_link_info_error"
 *
 * @param ports - Array of port configurations (usually just Uart1)
 * @returns JSON string of the link configuration
 */
export function generateN720LinkConfig(
  ports: Array<{
    name: string;         // "Uart1" or "Uart2"
    proto: number;        // 1 = Modbus RTU
    baudRate: number;     // 9600
    dataBit: number;      // 8
    parity: number;       // 0 = None
    stopBit: number;      // 1
  }> = [{
    name: 'Uart1',
    proto: 1,
    baudRate: 9600,
    dataBit: 8,
    parity: 0,
    stopBit: 1,
  }]
): string {
  const links = ports.map(port => ({
    enable: 1,
    name: port.name,
    proto: port.proto,
    baud_rate: port.baudRate,
    data_bit: port.dataBit,
    parity: port.parity,
    stop_bit: port.stopBit,
    pack_len: 512,
    pack_time: 100,
  }));

  // The link format expected by N720
  const linkConfig = {
    link: links,
  };

  return JSON.stringify(linkConfig);
}
